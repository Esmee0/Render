<!DOCTYPE html>
<html>
<head>
  <title>Relayrobot Dashboard</title> 
  <style>
body {
  background: #181a1d;
  color: #eee;
  font-family: 'Segoe UI', 'Roboto', sans-serif;
  min-height: 100vh;
  margin: 0;
  display: flex; flex-direction: column; align-items: center;
}
h1 {
  margin: 2.2rem 0 1.1rem 0;
  color: #3ed6fa;
  font-size: 2.3rem;
  letter-spacing: 0.02em;
  font-weight: 700;
  text-shadow: 0 6px 30px #000a;
}
#top-info {
  margin-top: 0.2rem;
  color: #a7b2c3;
  font-size: 0.95rem;
}
#dashboard-flex {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  justify-content: center;
  gap: 2.5rem;
  width: 100vw;
  max-width: 1200px;
  margin-top: 2.5rem;
}
.robot-card,
.robot-card-big {
  background: #23252d;
  border-radius: 1.6rem;
  box-shadow: 0 6px 30px #007abba1;
  display: flex; flex-direction: column; align-items: center;
  margin: 0;
  transition: box-shadow 0.13s, transform 0.18s, filter 0.11s;
  border: 2.5px solid transparent;
  cursor: pointer;
}
.robot-card {
  min-width: 230px; max-width: 340px; padding: 2rem 2.2rem 2.1rem 2.2rem;
}
.robot-card-big { 
  min-width: 370px; max-width: 440px; padding: 2.7rem 3rem 2.6rem 3rem; 
  z-index:2; box-shadow: 0 14px 60px #0bfdfe41;
}
.robot-card:hover, .robot-card-big:hover { border: 2.5px solid #2af8ff; filter:brightness(1.07);}
.robot-card.selected { border: 2.5px solid #2af8ff; filter: brightness(1.14);}
.tesla-car-svg { width: 160px; height: 76px; margin-bottom: 1.09rem;}
.robot-card-big .tesla-car-svg { width: 220px; height: 106px; margin-bottom: 1.6rem;}
.robot-title { color: #32e6ff; margin-bottom: 0.38em; font-weight: 600; font-size: 1.18em; text-align: center;}
.robot-card-big .robot-title { font-size: 1.46em;}

.status-box {
  text-align: center;
  margin: 0.8rem 0 0 0;
  font-size: 1.09rem;
  font-weight: 600;
  letter-spacing: 0.01em;
  min-height: 1.8em;
}
.status-box.obstacle { color: #ff4848; }
.status-box.moving { color: #39ffb2; }
.status-box.waiting { color: #ffd700; }
.status-box.offline { color: #8f96a7; }

.metrics {
  margin-top: 0.8rem;
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  text-align: center;
  color: #95d5e7;
  font-size: 0.98rem;
  min-height: 3.2rem;
}
.metric-line b { color: #b1efff; font-weight: 700; }
.muted { color: #8f96a7; font-size: 0.9rem; margin-top: 0.15rem; }

#focus-controls {
  margin-top: 1.1em;
  display: flex; flex-direction: row; gap: 1.8em; justify-content: center;
}
.control-btn {
  background: linear-gradient(92deg,#2af8ff 20%,#48d6be 90%);
  color: #0e2d3f; font-size: 1.09em; padding: 0.56em 1.5em; border: none;
  border-radius: 0.88em; font-weight: 700; margin: 0 0.33em;
  cursor: pointer; transition: filter 0.09s;
  box-shadow: 0 2px 12px #11eae745;
}
.control-btn.off {
  background: linear-gradient(92deg,#ff4848 30%,#ffd700 95%);
  color: #251f00;
}
.control-btn:active { filter: brightness(0.91);}

#sidebar-right {
  display: flex;
  flex-direction: column;
  gap: 1.7rem;
  align-items: center;
}
@media (max-width: 900px) {
  #dashboard-flex { flex-direction: column; align-items:center; gap: 2rem;}
  #sidebar-right { flex-direction: row; gap: 1.3rem;}
  .robot-card, .robot-card-big { min-width: 80vw; max-width: 99vw;}
}
  </style>
</head>

<body>
<h1>Relayrobot Dashboard</h1>
<div id="top-info">Connecting…</div>
<div id="dashboard-flex"></div>

<script>
const robotIdList = ["Pink Panther", "James Bond", "BDP"];
let allRobots = [];
let robotMap = {};
let focusRobotId = null;

function getStatusProps(statusText, isOffline) {
  if (isOffline) return { fill:'#888', glass:'#cccccc', lights:'#adacac', status:'offline' };
  let L = (statusText||"").toLowerCase();
  if (L.includes("object") || L.includes("obstacle")) return { fill:'#ff4848', glass:'#ffd7c0', lights:'#ffe3d6', status:'obstacle' };
  if (L.includes("wait")) return { fill:'#ffd700', glass:'#fffbe4', lights:'#fffbe0', status:'waiting' };
  if (L.length > 1) return { fill:'#23bffe', glass:'#fff', lights:'#fffbe0', status:'moving' };
  return { fill:'#888', glass:'#cccccc', lights:'#adacac', status:'offline' };
}

function normalizeRobotsPayload(payload) {
  if (Array.isArray(payload)) return payload;

  if (payload && typeof payload === "object") {
    const keys = Object.keys(payload);
    // If dict like {"R1":"...","R2":"..."}
    if (keys.length && typeof payload[keys[0]] === "string") {
      const idMap = { "R1": "Pink Panther", "R2": "James Bond", "R3": "BDP" };
      return Object.keys(idMap).map(rid => ({
        robot_id: idMap[rid],
        robot_name: idMap[rid],
        ping_count: 0,
        last_seen: null,
        last_data: payload[rid] || "No data"
      }));
    }

    // Generic object → try to convert
    return keys.map(k => {
      const v = payload[k];
      if (v && typeof v === "object") {
        return {
          robot_id: v.robot_id || k,
          robot_name: v.robot_name || k,
          ping_count: v.ping_count || 0,
          last_seen: v.last_seen || null,
          last_data: v.last_data || ""
        };
      }
      return { robot_id: k, robot_name: k, ping_count: 0, last_seen: null, last_data: String(v) };
    });
  }

  return [];
}

// Pulls useful info from last_data text.
function parseTelemetry(lastData) {
  const text = (lastData || "").toString();

  // action from keywords
  const L = text.toLowerCase();
  let action = "";
  if (L.includes("turning left")) action = "Turning Left";
  else if (L.includes("turning right")) action = "Turning Right";
  else if (L.includes("going straight") || L.includes("forward")) action = "Going Straight";
  else if (L.includes("lost the line")) action = "Searching (Lost line)";
  else if (L.includes("waiting")) action = "Waiting";
  else if (L.includes("started the race") || L.includes("start")) action = "Started";
  else if (L.includes("object") || L.includes("obstacle")) action = "Obstacle Detected";
  else if (text.trim().length) action = text.trim(); // fallback: show raw
  else action = "No data";

  // speed (matches "Motor Speed: 123" or "MotorSpeed 123")
  let speed = "";
  const m1 = text.match(/motor\s*speed\s*:\s*([0-9.]+)/i);
  const m2 = text.match(/motorspeed\s*[: ]\s*([0-9.]+)/i);
  if (m1) speed = m1[1];
  else if (m2) speed = m2[1];

  // distance (matches "Distance: 12.3" or "Distance 12.3")
  let distance = "";
  const d1 = text.match(/distance\s*:\s*([0-9.]+)/i);
  const d2 = text.match(/distance\s+([0-9.]+)/i);
  if (d1) distance = d1[1];
  else if (d2) distance = d2[1];

  return { action, speed, distance };
}

function formatRobotCard(r, isOffline, isBig, selected) {
  const st = getStatusProps(r.last_data, isOffline);
  const tele = parseTelemetry(r.last_data);

  const seenStr = r.last_seen ? new Date(r.last_seen).toLocaleTimeString() : "-";

  return `
  <div class="${isBig?'robot-card-big':'robot-card'}${selected?' selected':''}"
       data-id="${r.robot_id}" tabindex="0" title="Click me">
    <div class="robot-title">${r.robot_name || r.robot_id}</div>

    <svg class="tesla-car-svg" viewBox="0 0 180 86">
      <ellipse cx="90" cy="80" rx="65" ry="6" fill="#232c33" opacity="0.21"/>
      <rect x="27" y="44" width="126" height="23" rx="11" fill="#15171a"/>
      <rect x="30" y="42" width="120" height="19" rx="9" fill="${st.fill}"/>
      <rect x="75" y="37" width="30" height="13" rx="6.5" fill="${st.glass}" fill-opacity="0.72"/>
      <circle cx="47" cy="72" r="12" fill="#222" stroke="#111" stroke-width="3"/>
      <circle cx="133" cy="72" r="12" fill="#222" stroke="#111" stroke-width="3"/>
      <ellipse cx="31" cy="53" rx="4" ry="2" fill="${st.lights}" />
      <ellipse cx="148" cy="53" rx="4" ry="2" fill="${st.lights}" />
    </svg>

    <div class="status-box ${st.status}">
      ${isOffline ? "Offline" : tele.action}
    </div>

    <div class="metrics">
      <div class="metric-line"><b>Speed:</b> ${isOffline ? "-" : (tele.speed ? tele.speed : "-")}</div>
      <div class="metric-line"><b>Distance:</b> ${isOffline ? "-" : (tele.distance ? tele.distance : "-")}</div>
      <div class="muted">Seen: ${seenStr}</div>
    </div>

    ${isBig ? `
    <div id="focus-controls">
      <button class="control-btn" onclick="sendRobotCommand('${r.robot_id}', 'START');event.stopPropagation();">&#9654; On</button>
      <button class="control-btn off" onclick="sendRobotCommand('${r.robot_id}', 'STOP');event.stopPropagation();">&#9632; Off</button>
    </div>` : ''}
  </div>`;
}

async function fetchRobots() {
  const topInfo = document.getElementById("top-info");
  try {
    const res = await fetch("/api/robots", { cache: "no-store" });
    const payload = await res.json();
    const robotsArr = normalizeRobotsPayload(payload);

    robotMap = {};
    robotsArr.forEach(r => { robotMap[r.robot_id] = r; });

    // Fixed order + fill missing
    allRobots = robotIdList.map(id => {
      return robotMap[id] || { robot_id: id, robot_name: id, ping_count: 0, last_seen: null, last_data: "" };
    });

    if (topInfo) topInfo.textContent = `Live • last update ${new Date().toLocaleTimeString()}`;
    updateDisplay();
  } catch (e) {
    if (topInfo) topInfo.textContent = `Disconnected • retrying…`;
  }
}

function updateDisplay() {
  const now = Date.now();
  const dashboard = document.getElementById("dashboard-flex");
  if (!dashboard) return;

  if (!allRobots.length) {
    dashboard.innerHTML = `<div class="robot-card"><div class="robot-title">Geen robot online</div></div>`;
    return;
  }

  if (focusRobotId) {
    const bigIx = allRobots.findIndex(r => r.robot_id === focusRobotId);
    if (bigIx < 0) { focusRobotId = null; return; }

    const miniIx = [];
    for (let i = 0; i < allRobots.length; ++i) if (i !== bigIx) miniIx.push(i);

    dashboard.innerHTML = '';
    const r = allRobots[bigIx];

    const lastPing = r.last_seen ? new Date(r.last_seen).getTime() : 0;
    const isOffline = (!r.last_seen) || ((now - lastPing) / 1000 > 10);

    dashboard.innerHTML += formatRobotCard(r, isOffline, true, true);
    dashboard.innerHTML += `<div id="sidebar-right"></div>`;

    const sidebar = document.getElementById("sidebar-right");
    miniIx.forEach(ix => {
      const rr = allRobots[ix];
      const lp = rr.last_seen ? new Date(rr.last_seen).getTime() : 0;
      const off = (!rr.last_seen) || ((now - lp) / 1000 > 10);
      sidebar.innerHTML += formatRobotCard(rr, off, false, false);
    });

    const allCards = document.querySelectorAll('.robot-card, .robot-card-big');
    allCards.forEach(el => {
      const id = el.getAttribute("data-id");
      if (id === focusRobotId) {
        el.onclick = () => { focusRobotId = null; updateDisplay(); };
        el.onkeyup = (e) => { if (e.key === 'Enter') { focusRobotId = null; updateDisplay(); } };
      } else {
        el.onclick = () => { focusRobotId = id; updateDisplay(); };
        el.onkeyup = (e) => { if (e.key === 'Enter') { focusRobotId = id; updateDisplay(); } };
      }
    });
  } else {
    dashboard.innerHTML = allRobots.map(r => {
      const lastPing = r.last_seen ? new Date(r.last_seen).getTime() : 0;
      const isOffline = (!r.last_seen) || ((now - lastPing) / 1000 > 10);
      return formatRobotCard(r, isOffline, false, false);
    }).join('');

    Array.from(document.querySelectorAll(".robot-card")).forEach(el => {
      el.onclick = () => { focusRobotId = el.getAttribute("data-id"); updateDisplay(); };
      el.onkeyup = (e) => { if (e.key === 'Enter') { focusRobotId = el.getAttribute("data-id"); updateDisplay(); } };
    });
  }
}

function sendRobotCommand(robotId, cmd) {
  fetch('/api/command', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ robot_id: robotId, command: cmd })
  })
  .then(r => r.json())
  .then(obj => alert('Commando verstuurd: ' + obj.status))
  .catch(() => alert('Command failed'));
}

fetchRobots();
setInterval(fetchRobots, 1000);
</script>

</body>
</html>
