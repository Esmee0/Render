<!DOCTYPE html>
<html>
<head>
  <title>Relayrobot Dashboard</title> 
  <style>
body {
  background: #181a1d;
  color: #eee;
  font-family: 'Segoe UI', 'Roboto', sans-serif;
  min-height: 100vh;
  margin: 0;
  display: flex; flex-direction: column; align-items: center;
}
h1 {
  margin: 2.2rem 0 1.1rem 0;
  color: #3ed6fa;
  font-size: 2.3rem;
  letter-spacing: 0.02em;
  font-weight: 700;
  text-shadow: 0 6px 30px #000a;
}
#top-info {
  margin-top: 0.2rem;
  color: #a7b2c3;
  font-size: 0.95rem;
}
#dashboard-flex {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  justify-content: center;
  gap: 2.5rem;
  width: 100vw;
  max-width: 1200px;
  margin-top: 2.5rem;
}
.robot-card,
.robot-card-big {
  background: #23252d;
  border-radius: 1.6rem;
  box-shadow: 0 6px 30px #007abba1;
  display: flex; flex-direction: column; align-items: center;
  margin: 0;
  transition: box-shadow 0.13s, transform 0.18s, filter 0.11s;
  border: 2.5px solid transparent;
  cursor: pointer;
}
.robot-card {
  min-width: 230px; max-width: 340px; padding: 2rem 2.2rem 2.1rem 2.2rem;
}
.robot-card-big { 
  min-width: 370px; max-width: 440px; padding: 2.7rem 3rem 2.6rem 3rem; 
  z-index:2; box-shadow: 0 14px 60px #0bfdfe41;
}
.robot-card:hover, .robot-card-big:hover { border: 2.5px solid #2af8ff; filter:brightness(1.07);}
.robot-card.selected { border: 2.5px solid #2af8ff; filter: brightness(1.14);}
.tesla-car-svg { width: 160px; height: 76px; margin-bottom: 1.09rem;}
.robot-card-big .tesla-car-svg { width: 220px; height: 106px; margin-bottom: 1.6rem;}
.robot-title { color: #32e6ff; margin-bottom: 0.38em; font-weight: 600; font-size: 1.18em; text-align: center;}
.robot-card-big .robot-title { font-size: 1.46em;}

.status-box {
  text-align: center;
  margin: 0.8rem 0 0 0;
  font-size: 1.09rem;
  font-weight: 600;
  letter-spacing: 0.01em;
  min-height: 1.8em;
}
.status-box.obstacle { color: #ff4848; }
.status-box.moving { color: #39ffb2; }
.status-box.waiting { color: #ffd700; }
.status-box.offline { color: #8f96a7; }

.metrics {
  margin-top: 0.8rem;
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  text-align: center;
  color: #95d5e7;
  font-size: 0.98rem;
  min-height: 4.2rem;
}
.metric-line b { color: #b1efff; font-weight: 700; }
.muted { color: #8f96a7; font-size: 0.9rem; margin-top: 0.15rem; }

.raw {
  margin-top: 0.45rem;
  color: #c7d0dd;
  font-size: 0.85rem;
  max-width: 320px;
  text-align: center;
  opacity: 0.9;
  word-break: break-word;
}

#focus-controls {
  margin-top: 1.1em;
  display: flex; flex-direction: row; gap: 1.8em; justify-content: center;
}
.control-btn {
  background: linear-gradient(92deg,#2af8ff 20%,#48d6be 90%);
  color: #0e2d3f; font-size: 1.09em; padding: 0.56em 1.5em; border: none;
  border-radius: 0.88em; font-weight: 700; margin: 0 0.33em;
  cursor: pointer; transition: filter 0.09s;
  box-shadow: 0 2px 12px #11eae745;
}
.control-btn.off {
  background: linear-gradient(92deg,#ff4848 30%,#ffd700 95%);
  color: #251f00;
}
.control-btn:active { filter: brightness(0.91);}

#sidebar-right {
  display: flex;
  flex-direction: column;
  gap: 1.7rem;
  align-items: center;
}
@media (max-width: 900px) {
  #dashboard-flex { flex-direction: column; align-items:center; gap: 2rem;}
  #sidebar-right { flex-direction: row; gap: 1.3rem;}
  .robot-card, .robot-card-big { min-width: 80vw; max-width: 99vw;}
  .raw { max-width: 80vw; }
}
  </style>
</head>

<body>
<h1>Relayrobot Dashboard</h1>
<div id="top-info">Connecting…</div>
<div id="dashboard-flex"></div>

<script>
// ✅ Use REAL IDs as keys (what the API typically returns)
const robotOrder = ["R1","R2","R3"];

// ✅ Pretty names for display
const robotNames = {
  R1: "Pink Panther",
  R2: "James Bond",
  R3: "BDP"
};

let allRobots = [];
let robotMap = {};
let focusRobotId = null;

function safeParseTime(t) {
  if (!t) return null;
  const d = new Date(t);
  if (!isNaN(d.getTime())) return d;

  // sometimes backend might send seconds since epoch as number/string
  const n = Number(t);
  if (!Number.isNaN(n) && n > 1000000000) {
    const d2 = new Date(n * (n < 2000000000 ? 1000 : 1)); // guess seconds vs ms
    if (!isNaN(d2.getTime())) return d2;
  }
  return null;
}

function getStatusProps(statusText, isOffline) {
  if (isOffline) return { fill:'#888', glass:'#cccccc', lights:'#adacac', status:'offline' };
  const L = (statusText||"").toLowerCase();
  if (L.includes("object") || L.includes("obstacle")) return { fill:'#ff4848', glass:'#ffd7c0', lights:'#ffe3d6', status:'obstacle' };
  if (L.includes("wait")) return { fill:'#ffd700', glass:'#fffbe4', lights:'#fffbe0', status:'waiting' };
  if (L.length > 1) return { fill:'#23bffe', glass:'#fff', lights:'#fffbe0', status:'moving' };
  return { fill:'#888', glass:'#cccccc', lights:'#adacac', status:'offline' };
}

function normalizePayload(payload) {
  // Accept:
  // 1) array [{robot_id,...}, ...]
  // 2) object map {"R1":"No data", ...}
  // 3) object map {"R1":{robot_id,...}, ...}

  if (Array.isArray(payload)) return payload;

  if (payload && typeof payload === "object") {
    const keys = Object.keys(payload);
    if (!keys.length) return [];

    // {"R1":"No data"}
    if (typeof payload[keys[0]] === "string") {
      return keys.map(k => ({
        robot_id: k,
        robot_name: robotNames[k] || k,
        ping_count: 0,
        last_seen: null,
        last_data: payload[k] || ""
      }));
    }

    // {"R1":{...}}
    return keys.map(k => {
      const v = payload[k];
      if (v && typeof v === "object") {
        return {
          robot_id: v.robot_id || k,
          robot_name: v.robot_name || robotNames[v.robot_id] || robotNames[k] || k,
          ping_count: v.ping_count || 0,
          last_seen: v.last_seen || null,
          last_data: v.last_data || ""
        };
      }
      return { robot_id: k, robot_name: robotNames[k] || k, ping_count: 0, last_seen: null, last_data: String(v) };
    });
  }

  return [];
}

function parseTelemetry(lastData) {
  const text = (lastData || "").toString();
  const L = text.toLowerCase();

  let action = "";
  if (L.includes("turning left")) action = "Turning Left";
  else if (L.includes("turning right")) action = "Turning Right";
  else if (L.includes("going straight") || L.includes("forwardpid") || L.includes("moveforward")) action = "Going Straight";
  else if (L.includes("lost the line")) action = "Searching (Lost line)";
  else if (L.includes("waiting")) action = "Waiting";
  else if (L.includes("started the race")) action = "Started Race";
  else if (L.includes("object") || L.includes("obstacle")) action = "Obstacle Detected";
  else if (text.trim().length) action = text.trim();
  else action = "No data";

  let speed = "";
  const m = text.match(/motor\s*speed\s*:\s*([0-9.]+)/i);
  if (m) speed = m[1];

  let distance = "";
  const d = text.match(/distance\s*:\s*([0-9.]+)/i);
  if (d) distance = d[1];

  return { action, speed, distance, raw: text.trim() };
}

function formatRobotCard(r, isOffline, isBig, selected) {
  const st = getStatusProps(r.last_data, isOffline);
  const tele = parseTelemetry(r.last_data);

  const seenDate = safeParseTime(r.last_seen);
  const seenStr = seenDate ? seenDate.toLocaleTimeString() : "-";

  return `
  <div class="${isBig?'robot-card-big':'robot-card'}${selected?' selected':''}"
       data-id="${r.robot_id}" tabindex="0" title="Click me">
    <div class="robot-title">${robotNames[r.robot_id] || r.robot_name || r.robot_id}</div>

    <svg class="tesla-car-svg" viewBox="0 0 180 86">
      <ellipse cx="90" cy="80" rx="65" ry="6" fill="#232c33" opacity="0.21"/>
      <rect x="27" y="44" width="126" height="23" rx="11" fill="#15171a"/>
      <rect x="30" y="42" width="120" height="19" rx="9" fill="${st.fill}"/>
      <rect x="75" y="37" width="30" height="13" rx="6.5" fill="${st.glass}" fill-opacity="0.72"/>
      <circle cx="47" cy="72" r="12" fill="#222" stroke="#111" stroke-width="3"/>
      <circle cx="133" cy="72" r="12" fill="#222" stroke="#111" stroke-width="3"/>
      <ellipse cx="31" cy="53" rx="4" ry="2" fill="${st.lights}" />
      <ellipse cx="148" cy="53" rx="4" ry="2" fill="${st.lights}" />
    </svg>

    <div class="status-box ${st.status}">
      ${isOffline ? "Offline" : tele.action}
    </div>

    <div class="metrics">
      <div class="metric-line"><b>Speed:</b> ${isOffline ? "-" : (tele.speed || "-")}</div>
      <div class="metric-line"><b>Distance:</b> ${isOffline ? "-" : (tele.distance || "-")}</div>
      <div class="muted">Seen: ${seenStr}</div>
      <div class="raw">${tele.raw ? tele.raw : ""}</div>
    </div>

    ${isBig ? `
    <div id="focus-controls">
      <button class="control-btn" onclick="sendRobotCommand('${r.robot_id}', 'START');event.stopPropagation();">&#9654; On</button>
      <button class="control-btn off" onclick="sendRobotCommand('${r.robot_id}', 'STOP');event.stopPropagation();">&#9632; Off</button>
    </div>` : ''}
  </div>`;
}

async function fetchRobots() {
  const topInfo = document.getElementById("top-info");
  try {
    const res = await fetch("/api/robots", { cache: "no-store" });
    const payload = await res.json();
    const robotsArr = normalizePayload(payload);

    robotMap = {};
    robotsArr.forEach(r => { robotMap[r.robot_id] = r; });

    // Always build the 3 robots in order R1,R2,R3
    allRobots = robotOrder.map(id => {
      return robotMap[id] || {
        robot_id: id,
        robot_name: robotNames[id] || id,
        ping_count: 0,
        last_seen: null,
        last_data: ""
      };
    });

    if (topInfo) topInfo.textContent = `Live • last update ${new Date().toLocaleTimeString()}`;
    updateDisplay();
  } catch (e) {
    if (topInfo) topInfo.textContent = `Disconnected • retrying…`;
  }
}

function updateDisplay() {
  const now = Date.now();
  const dashboard = document.getElementById("dashboard-flex");
  if (!dashboard) return;

  const isRobotOffline = (r) => {
    // If we have a last_seen time, use it:
    const d = safeParseTime(r.last_seen);
    if (d) return (now - d.getTime()) > 10000; // 10s

    // If no timestamp exists, but we DO have data, treat it as online:
    if ((r.last_data || "").trim() && (r.last_data || "").toLowerCase() !== "no data") return false;

    return true;
  };

  if (focusRobotId) {
    const bigIx = allRobots.findIndex(r => r.robot_id === focusRobotId);
    if (bigIx < 0) { focusRobotId = null; return; }

    const miniIx = [];
    for (let i = 0; i < allRobots.length; ++i) if (i !== bigIx) miniIx.push(i);

    dashboard.innerHTML = '';
    const r = allRobots[bigIx];
    dashboard.innerHTML += formatRobotCard(r, isRobotOffline(r), true, true);
    dashboard.innerHTML += `<div id="sidebar-right"></div>`;

    const sidebar = document.getElementById("sidebar-right");
    miniIx.forEach(ix => {
      const rr = allRobots[ix];
      sidebar.innerHTML += formatRobotCard(rr, isRobotOffline(rr), false, false);
    });

    const allCards = document.querySelectorAll('.robot-card, .robot-card-big');
    allCards.forEach(el => {
      const id = el.getAttribute("data-id");
      if (id === focusRobotId) {
        el.onclick = () => { focusRobotId = null; updateDisplay(); };
        el.onkeyup = (e) => { if (e.key === 'Enter') { focusRobotId = null; updateDisplay(); } };
      } else {
        el.onclick = () => { focusRobotId = id; updateDisplay(); };
        el.onkeyup = (e) => { if (e.key === 'Enter') { focusRobotId = id; updateDisplay(); } };
      }
    });
  } else {
    dashboard.innerHTML = allRobots.map(r => {
      return formatRobotCard(r, isRobotOffline(r), false, false);
    }).join('');

    Array.from(document.querySelectorAll(".robot-card")).forEach(el => {
      el.onclick = () => { focusRobotId = el.getAttribute("data-id"); updateDisplay(); };
      el.onkeyup = (e) => { if (e.key === 'Enter') { focusRobotId = el.getAttribute("data-id"); updateDisplay(); } };
    });
  }
}

function sendRobotCommand(robotId, cmd) {
  fetch('/api/command', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ robot_id: robotId, command: cmd })
  })
  .then(r => r.json())
  .then(obj => alert('Commando verstuurd: ' + (obj.status || "ok")))
  .catch(() => alert('Command failed'));
}

fetchRobots();
setInterval(fetchRobots, 1000);
</script>

</body>
</html>
