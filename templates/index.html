<!-- templates/index.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Relayrobot Dashboard</title>
  <link rel="stylesheet" href="/static/styles.css">
</head>

<body>
  <h1>Relayrobot Dashboard</h1>
  <div id="top-info">Connecting…</div>

  <div id="controls">
    <div id="relayState" class="pill">Relay: idle</div>
    <button id="relayBtn" class="btn btn-auto">▶ Relay Mode: OFF</button>
    <button id="stopAllBtn" class="btn btn-stop">■ Stop All</button>
  </div>

  <div id="dashboard-flex"></div>

<script>
/*
  SIMPLE EXPLANATION:

  - The website calls GET /api/robots every ~0.8s.
  - We show 3 cards: Pink Panther, James Bond, BDP.
  - We read the latest message text (last_data) to show:
      action, speed, distance
  - Relay Mode:
      Pink Panther starts by itself.
      When Pink Panther says "Race Finished" -> send START_R2 to James Bond.
      When James Bond says "Race Finished" -> send START_R3 to BDP.
  - Manual buttons still work:
      START and STOP go to the robot you click.
*/

// ----- Fixed robot “slots” shown on screen -----
const ROBOTS = ["Pink Panther", "James Bond", "BDP"];

// Accept different ids coming from API (R1/R2/R3 or names)
const ALIASES = {
  "Pink Panther": ["pink panther", "r1", "robot 1", "1"],
  "James Bond":   ["james bond", "r2", "robot 2", "2"],
  "BDP":          ["bdp", "r3", "robot 3", "3"]
};

// Relay steps: watch who, then start the next robot
const RELAY = [
  { watch: "Pink Panther", nextName: "James Bond", cmd: "START_R2" },
  { watch: "James Bond",   nextName: "BDP",        cmd: "START_R3" },
  { watch: "BDP",          nextName: null,         cmd: null }
];

// ----- UI state -----
let focus = null;                 // clicked robot card (big view)
let allRobots = [];               // always 3 items
let relayEnabled = false;
let relayStep = 0;
let lastRelaySentAt = 0;
const RELAY_COOLDOWN_MS = 2500;

// We keep last known values so speed/distance don’t “disappear”
const cache = {
  "Pink Panther": { action:"No data", speed:"-", distance:"-", raw:"", seen:null },
  "James Bond":   { action:"No data", speed:"-", distance:"-", raw:"", seen:null },
  "BDP":          { action:"No data", speed:"-", distance:"-", raw:"", seen:null }
};

// ----- Small helpers -----
function setTop(text){ const el=document.getElementById("top-info"); if(el) el.textContent=text; }
function setRelayText(text){ const el=document.getElementById("relayState"); if(el) el.textContent=text; }
function setRelayBtn(){ const b=document.getElementById("relayBtn"); if(b) b.textContent = relayEnabled ? "▶ Relay Mode: ON" : "▶ Relay Mode: OFF"; }

function safeDate(x){
  if(!x) return null;
  let d=new Date(x);
  if(!isNaN(d.getTime())) return d;
  // handle "YYYY-MM-DD HH:MM:SS" by converting space -> T
  if(typeof x==="string" && x.includes(" ") && !x.includes("T")){
    d=new Date(x.replace(" ","T"));
    if(!isNaN(d.getTime())) return d;
  }
  return null;
}

function normalizePayload(p){
  // API can return:
  // - list of robots [{robot_id,...}]
  // - dict {"R1":"...","R2":"..."}
  if(Array.isArray(p)) return p;

  if(p && typeof p === "object"){
    const keys=Object.keys(p);
    if(!keys.length) return [];
    if(typeof p[keys[0]] === "string"){
      return keys.map(k=>({ robot_id:k, robot_name:k, last_seen:null, ping_count:0, last_data:p[k]||"" }));
    }
  }
  return [];
}

// Find the best matching object from API for each robot slot
function matchRobot(slotName, robotsArr){
  const a = ALIASES[slotName];
  const lower = a.map(x=>x.toLowerCase());

  // match by robot_id or robot_name
  let r = robotsArr.find(x => lower.includes(String(x.robot_id||"").toLowerCase()))
       || robotsArr.find(x => lower.includes(String(x.robot_name||"").toLowerCase()));

  // if not found, return empty object for that slot
  return r || { robot_id: slotName, robot_name: slotName, last_seen:null, ping_count:0, last_data:"" };
}

// Convert raw text into nice “action”, and extract speed/distance if present
function parseTelemetry(text){
  const raw = (text||"").toString().trim();
  const L = raw.toLowerCase();

  // pick a simple action label
  let action = "No data";
  if(L.includes("race finished")) action="Race Finished";
  else if(L.includes("dropping cone")) action="Dropping Cone";
  else if(L.includes("started the race")) action="Started Race";
  else if(L.includes("waiting for start")) action="Waiting for start";
  else if(L.includes("turning left")) action="Turning Left";
  else if(L.includes("turning right")) action="Turning Right";
  else if(L.includes("lost the line")) action="Searching (Lost line)";
  else if(L.includes("object found") || L.includes("obstacle")) action="Obstacle Detected";
  else if(L.includes("robot online")) action="Online";
  else if(L.includes("motor speed")) action="Moving";
  else if(raw.length) action=raw;

  // extract numbers if they exist
  let speed=null, dist=null;
  const m=raw.match(/motor\s*speed\s*:\s*([0-9.]+)/i);
  if(m) speed=m[1];
  const d=raw.match(/distance\s*:\s*([0-9.]+)/i);
  if(d) dist=d[1];

  return { action, speed, dist, raw };
}

function isOffline(slotName){
  // If we have any real message, we treat it as online.
  // Also: if last_seen is older than 10s, treat as offline.
  const seen = cache[slotName].seen;
  const raw = (cache[slotName].raw||"").trim().toLowerCase();
  if(raw && raw !== "no data") return false;
  if(seen) return (Date.now()-seen.getTime()) > 10000;
  return true;
}

function statusStyle(action, offline){
  if(offline) return { status:"offline", fill:"#888", glass:"#cccccc", lights:"#adacac" };
  const L=(action||"").toLowerCase();
  if(L.includes("finished")) return { status:"finished", fill:"#c7a6ff", glass:"#fff", lights:"#fffbe0" };
  if(L.includes("obstacle")) return { status:"obstacle", fill:"#ff4848", glass:"#ffd7c0", lights:"#ffe3d6" };
  if(L.includes("wait")) return { status:"waiting", fill:"#ffd700", glass:"#fffbe4", lights:"#fffbe0" };
  return { status:"moving", fill:"#23bffe", glass:"#fff", lights:"#fffbe0" };
}

// Send command to Render, which forwards to your laptop API
async function sendRobotCommand(robotName, cmd){
  try{
    await fetch("/api/command", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ robot_id: robotName, command: cmd })
    });
  }catch(e){}
}

// ----- Relay logic -----
function finished(slotName){
  const raw = (cache[slotName].raw||"").toLowerCase();
  const action = (cache[slotName].action||"").toLowerCase();
  return raw.includes("race finished") || action.includes("race finished");
}

async function relayTick(){
  if(!relayEnabled) return;

  const step = RELAY[relayStep];
  if(!step){ relayEnabled=false; setRelayBtn(); setRelayText("Relay: done ✅"); return; }

  // Wait until the watched robot says "Race Finished"
  if(!finished(step.watch)){
    setRelayText(`Relay: watching ${step.watch}…`);
    return;
  }

  // If there is no next robot, relay is done
  if(!step.nextName){
    relayEnabled=false; setRelayBtn(); setRelayText("Relay: done ✅");
    return;
  }

  // Small cooldown so we don’t spam commands
  const now=Date.now();
  if(now-lastRelaySentAt < RELAY_COOLDOWN_MS){
    setRelayText(`Relay: ${step.watch} finished • cooldown…`);
    return;
  }

  lastRelaySentAt=now;
  setRelayText(`Relay: ${step.watch} finished • sending ${step.cmd} → ${step.nextName}`);
  await sendRobotCommand(step.nextName, step.cmd);
  relayStep++;
}

// ----- Rendering -----
function cardHTML(slotName, apiRobot, big){
  const t = parseTelemetry(apiRobot.last_data);

  // Update cache with new info (so speed/distance stays)
  if(t.raw) cache[slotName].raw = t.raw;
  if(t.action && t.action !== "No data") cache[slotName].action = t.action;
  if(t.speed !== null) cache[slotName].speed = t.speed;
  if(t.dist !== null) cache[slotName].distance = t.dist;

  const seen = safeDate(apiRobot.last_seen);
  if(seen) cache[slotName].seen = seen;

  const offline = isOffline(slotName);
  const action = offline ? "Offline" : cache[slotName].action;
  const st = statusStyle(action, offline);

  const speed = offline ? "-" : cache[slotName].speed;
  const dist  = offline ? "-" : cache[slotName].distance;
  const raw   = offline ? "" : cache[slotName].raw;
  const seenStr = cache[slotName].seen ? cache[slotName].seen.toLocaleTimeString() : "-";

  return `
    <div class="${big?'robot-card-big':'robot-card'}" data-key="${slotName}" tabindex="0">
      <div class="robot-title">${slotName}</div>

      <svg class="tesla-car-svg" viewBox="0 0 180 86">
        <ellipse cx="90" cy="80" rx="65" ry="6" fill="#232c33" opacity="0.21"/>
        <rect x="27" y="44" width="126" height="23" rx="11" fill="#15171a"/>
        <rect x="30" y="42" width="120" height="19" rx="9" fill="${st.fill}"/>
        <rect x="75" y="37" width="30" height="13" rx="6.5" fill="${st.glass}" fill-opacity="0.72"/>
        <circle cx="47" cy="72" r="12" fill="#222" stroke="#111" stroke-width="3"/>
        <circle cx="133" cy="72" r="12" fill="#222" stroke="#111" stroke-width="3"/>
        <ellipse cx="31" cy="53" rx="4" ry="2" fill="${st.lights}" />
        <ellipse cx="148" cy="53" rx="4" ry="2" fill="${st.lights}" />
      </svg>

      <div class="status-box ${st.status}">${action}</div>

      <div class="metrics">
        <div class="metric-line"><b>Speed:</b> ${speed}</div>
        <div class="metric-line"><b>Distance:</b> ${dist}</div>
        <div class="muted">Seen: ${seenStr}</div>
        <div class="raw">${raw}</div>
      </div>

      ${big ? `
        <div id="focus-controls">
          <button class="control-btn" onclick="sendRobotCommand('${slotName}','START');event.stopPropagation();">&#9654; On</button>
          <button class="control-btn off" onclick="sendRobotCommand('${slotName}','STOP');event.stopPropagation();">&#9632; Off</button>
        </div>
      ` : ""}
    </div>
  `;
}

function render(){
  const dash=document.getElementById("dashboard-flex");
  if(!dash) return;

  if(focus){
    const big = allRobots.find(x=>x.slot===focus);
    const minis = allRobots.filter(x=>x.slot!==focus);

    dash.innerHTML = cardHTML(big.slot, big.data, true) + `<div id="sidebar-right"></div>`;
    const side=document.getElementById("sidebar-right");
    minis.forEach(m=> side.innerHTML += cardHTML(m.slot, m.data, false));

    document.querySelectorAll(".robot-card, .robot-card-big").forEach(el=>{
      const k=el.getAttribute("data-key");
      el.onclick = ()=>{ focus = (focus===k)?null:k; render(); };
      el.onkeyup = (e)=>{ if(e.key==="Enter"){ focus=(focus===k)?null:k; render(); } };
    });
  }else{
    dash.innerHTML = allRobots.map(x=>cardHTML(x.slot, x.data, false)).join("");
    document.querySelectorAll(".robot-card").forEach(el=>{
      el.onclick=()=>{ focus=el.getAttribute("data-key"); render(); };
      el.onkeyup=(e)=>{ if(e.key==="Enter"){ focus=el.getAttribute("data-key"); render(); } };
    });
  }
}

// ----- Main loop: fetch API -> update UI -> relay tick -----
async function fetchRobots(){
  try{
    const res = await fetch("/api/robots", { cache:"no-store" });
    const payload = await res.json();
    const arr = normalizePayload(payload);

    allRobots = ROBOTS.map(name => ({ slot:name, data: matchRobot(name, arr) }));

    setTop(`Live • last update ${new Date().toLocaleTimeString()}`);
    render();
    await relayTick();
  }catch(e){
    setTop("Disconnected • retrying…");
  }
}

// ----- Buttons -----
document.getElementById("relayBtn").onclick = ()=>{
  relayEnabled = !relayEnabled;
  if(relayEnabled){
    relayStep=0;
    lastRelaySentAt=0;
    setRelayText("Relay: watching Pink Panther…");
    // IMPORTANT: we do NOT start Pink Panther automatically
  }else{
    setRelayText("Relay: idle");
  }
  setRelayBtn();
};

document.getElementById("stopAllBtn").onclick = async ()=>{
  relayEnabled=false;
  setRelayBtn();
  setRelayText("Relay: stopped ■");
  // Stop everyone (manual emergency)
  await sendRobotCommand("Pink Panther","STOP");
  await sendRobotCommand("James Bond","STOP");
  await sendRobotCommand("BDP","STOP");
};

// Start everything
setRelayBtn();
fetchRobots();
setInterval(fetchRobots, 800);
</script>
</body>
</html>
