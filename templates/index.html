<!-- templates/index.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Relayrobot Dashboard</title>
  <link rel="stylesheet" href="/static/styles.css">
</head>

<body>
  <h1>Relayrobot Dashboard</h1>
  <div id="top-info">Connecting…</div>

  <div id="controls">
    <div id="relayState" class="pill">Relay: idle</div>
    <button id="relayBtn" class="btn btn-auto">▶ Relay Mode: OFF</button>
  </div>

  <div id="dashboard-flex"></div>

<script>
/*
  - Polls /api/robots every ~0.8s
  - Shows 3 robot cards
  - Relay Mode:
      Pink Panther finishes -> send START_R2
      James Bond finishes   -> send START_R3
  - We removed:
      - Stop All button
      - OFF button
      - Distance metric
  - Added:
      - Per-robot timer that starts when robot "starts" and stops on "Race Finished"
*/

// ----- Fixed robot “slots” shown on screen -----
const ROBOTS = ["Pink Panther", "James Bond", "BDP"];

// Accept different ids coming from API (R1/R2/R3 or names)
const ALIASES = {
  "Pink Panther": ["pink panther", "r1", "robot 1", "1"],
  "James Bond":   ["james bond", "r2", "robot 2", "2"],
  "BDP":          ["bdp", "r3", "robot 3", "3"]
};

// Relay steps: watch who, then start the next robot
const RELAY = [
  { watch: "Pink Panther", nextName: "James Bond", cmd: "START_R2" },
  { watch: "James Bond",   nextName: "BDP",        cmd: "START_R3" },
  { watch: "BDP",          nextName: null,         cmd: null }
];

// ----- UI state -----
let focus = null;
let allRobots = [];
let relayEnabled = false;
let relayStep = 0;
let lastRelaySentAt = 0;
const RELAY_COOLDOWN_MS = 2500;

// We keep last known values so speed doesn’t “disappear”
const cache = {
  "Pink Panther": { action:"No data", speed:"-", raw:"", seen:null },
  "James Bond":   { action:"No data", speed:"-", raw:"", seen:null },
  "BDP":          { action:"No data", speed:"-", raw:"", seen:null }
};

// ----- Timer state (per robot) -----
const timers = {
  "Pink Panther": { started:false, startMs:null, endMs:null },
  "James Bond":   { started:false, startMs:null, endMs:null },
  "BDP":          { started:false, startMs:null, endMs:null }
};

// ----- Small helpers -----
function setTop(text){ const el=document.getElementById("top-info"); if(el) el.textContent=text; }
function setRelayText(text){ const el=document.getElementById("relayState"); if(el) el.textContent=text; }
function setRelayBtn(){ const b=document.getElementById("relayBtn"); if(b) b.textContent = relayEnabled ? "▶ Relay Mode: ON" : "▶ Relay Mode: OFF"; }

function safeDate(x){
  if(!x) return null;
  let d=new Date(x);
  if(!isNaN(d.getTime())) return d;
  if(typeof x==="string" && x.includes(" ") && !x.includes("T")){
    d=new Date(x.replace(" ","T"));
    if(!isNaN(d.getTime())) return d;
  }
  return null;
}

function normalizePayload(p){
  if(Array.isArray(p)) return p;

  if(p && typeof p === "object"){
    const keys=Object.keys(p);
    if(!keys.length) return [];
    if(typeof p[keys[0]] === "string"){
      return keys.map(k=>({ robot_id:k, robot_name:k, last_seen:null, ping_count:0, last_data:p[k]||"" }));
    }
  }
  return [];
}

function matchRobot(slotName, robotsArr){
  const a = ALIASES[slotName];
  const lower = a.map(x=>x.toLowerCase());

  let r = robotsArr.find(x => lower.includes(String(x.robot_id||"").toLowerCase()))
       || robotsArr.find(x => lower.includes(String(x.robot_name||"").toLowerCase()));

  return r || { robot_id: slotName, robot_name: slotName, last_seen:null, ping_count:0, last_data:"" };
}

function parseTelemetry(text){
  const raw = (text||"").toString().trim();
  const L = raw.toLowerCase();

  let action = "No data";
  if(L.includes("race finished")) action="Race Finished";
  else if(L.includes("dropping cone")) action="Dropping Cone";
  else if(L.includes("started the race")) action="Started Race";
  else if(L.includes("waiting for start")) action="Waiting for start";
  else if(L.includes("turning left")) action="Turning Left";
  else if(L.includes("turning right")) action="Turning Right";
  else if(L.includes("lost the line")) action="Searching (Lost line)";
  else if(L.includes("object found") || L.includes("obstacle")) action="Obstacle Detected";
  else if(L.includes("robot online")) action="Online";
  else if(L.includes("motor speed")) action="Moving";
  else if(raw.length) action=raw;

  let speed=null;
  const m=raw.match(/motor\s*speed\s*:\s*([0-9.]+)/i);
  if(m) speed=m[1];

  return { action, speed, raw };
}

function isOffline(slotName){
  const seen = cache[slotName].seen;
  const raw = (cache[slotName].raw||"").trim().toLowerCase();
  if(raw && raw !== "no data") return false;
  if(seen) return (Date.now()-seen.getTime()) > 10000;
  return true;
}

function statusStyle(action, offline){
  if(offline) return { status:"offline", fill:"#888", glass:"#cccccc", lights:"#adacac" };
  const L=(action||"").toLowerCase();
  if(L.includes("finished")) return { status:"finished", fill:"#c7a6ff", glass:"#fff", lights:"#fffbe0" };
  if(L.includes("obstacle")) return { status:"obstacle", fill:"#ff4848", glass:"#ffd7c0", lights:"#ffe3d6" };
  if(L.includes("wait")) return { status:"waiting", fill:"#ffd700", glass:"#fffbe4", lights:"#fffbe0" };
  return { status:"moving", fill:"#23bffe", glass:"#fff", lights:"#fffbe0" };
}

function directionClass(action, raw){
  const a = (action || "").toLowerCase();
  const r = (raw || "").toLowerCase();

  if (a.includes("finished")) return "dir-finish";
  if (a.includes("offline")) return "dir-offline";
  if (a.includes("wait")) return "dir-wait";
  if (a.includes("obstacle")) return "dir-obstacle";

  if (a.includes("turning left") || r.includes("left")) return "dir-left";
  if (a.includes("turning right") || r.includes("right")) return "dir-right";

  return "dir-forward";
}

async function sendRobotCommand(robotName, cmd){
  try{
    await fetch("/api/command", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ robot_id: robotName, command: cmd })
    });
  }catch(e){}
}

// ----- Timer helpers -----
function shouldStartTimer(action, raw){
  const a=(action||"").toLowerCase();
  const r=(raw||"").toLowerCase();
  return a.includes("started race") || r.includes("started the race");
}

function shouldStopTimer(action, raw){
  const a=(action||"").toLowerCase();
  const r=(raw||"").toLowerCase();
  return a.includes("race finished") || r.includes("race finished");
}

function updateTimerState(slotName, action, raw){
  const t = timers[slotName];

  if(!t.started && shouldStartTimer(action, raw)){
    t.started = true;
    t.startMs = Date.now();
    t.endMs = null;
  }

  if(t.started && t.endMs === null && shouldStopTimer(action, raw)){
    t.endMs = Date.now();
  }
}

function formatMs(ms){
  if(ms === null || ms === undefined) return "--:--.--";
  const total = Math.max(0, ms);
  const minutes = Math.floor(total / 60000);
  const seconds = Math.floor((total % 60000) / 1000);
  const centis  = Math.floor((total % 1000) / 10);
  const mm = String(minutes).padStart(2,'0');
  const ss = String(seconds).padStart(2,'0');
  const cc = String(centis).padStart(2,'0');
  return `${mm}:${ss}.${cc}`;
}

function getTimerDisplay(slotName){
  const t = timers[slotName];
  if(!t.started) return { label:"Timer:", value:"--:--.--", running:false, done:false };
  if(t.endMs !== null) {
    return { label:"Time:", value: formatMs(t.endMs - t.startMs), running:false, done:true };
  }
  return { label:"Time:", value: formatMs(Date.now() - t.startMs), running:true, done:false };
}

// ----- Relay logic -----
function finished(slotName){
  const raw = (cache[slotName].raw||"").toLowerCase();
  const action = (cache[slotName].action||"").toLowerCase();
  return raw.includes("race finished") || action.includes("race finished");
}

async function relayTick(){
  if(!relayEnabled) return;

  const step = RELAY[relayStep];
  if(!step){ relayEnabled=false; setRelayBtn(); setRelayText("Relay: done ✅"); return; }

  if(!finished(step.watch)){
    setRelayText(`Relay: watching ${step.watch}…`);
    return;
  }

  if(!step.nextName){
    relayEnabled=false; setRelayBtn(); setRelayText("Relay: done ✅");
    return;
  }

  const now=Date.now();
  if(now-lastRelaySentAt < RELAY_COOLDOWN_MS){
    setRelayText(`Relay: ${step.watch} finished • cooldown…`);
    return;
  }

  lastRelaySentAt=now;
  setRelayText(`Relay: ${step.watch} finished • sending ${step.cmd} → ${step.nextName}`);
  await sendRobotCommand(step.nextName, step.cmd);
  relayStep++;
}

// ----- Rendering -----
function cardHTML(slotName, apiRobot, big){
  const parsed = parseTelemetry(apiRobot.last_data);

  if(parsed.raw) cache[slotName].raw = parsed.raw;
  if(parsed.action && parsed.action !== "No data") cache[slotName].action = parsed.action;
  if(parsed.speed !== null) cache[slotName].speed = parsed.speed;

  const seen = safeDate(apiRobot.last_seen);
  if(seen) cache[slotName].seen = seen;

  const offline = isOffline(slotName);
  const action = offline ? "Offline" : cache[slotName].action;
  const st = statusStyle(action, offline);

  const speed = offline ? "-" : cache[slotName].speed;
  const raw   = offline ? "" : cache[slotName].raw;
  const seenStr = cache[slotName].seen ? cache[slotName].seen.toLocaleTimeString() : "-";

  if(!offline){
    updateTimerState(slotName, action, raw);
  }

  const tDisp = getTimerDisplay(slotName);

  return `
    <div class="${big?'robot-card-big':'robot-card'}" data-key="${slotName}" tabindex="0">
      <div class="robot-title">${slotName}</div>

      <svg class="tesla-car-svg" viewBox="0 0 180 86">
        <ellipse cx="90" cy="80" rx="65" ry="6" fill="#232c33" opacity="0.21"/>
        <rect x="27" y="44" width="126" height="23" rx="11" fill="#15171a"/>
        <rect x="30" y="42" width="120" height="19" rx="9" fill="${st.fill}"/>
        <rect x="75" y="37" width="30" height="13" rx="6.5" fill="${st.glass}" fill-opacity="0.72"/>
        <circle cx="47" cy="72" r="12" fill="#222" stroke="#111" stroke-width="3"/>
        <circle cx="133" cy="72" r="12" fill="#222" stroke="#111" stroke-width="3"/>
        <ellipse cx="31" cy="53" rx="4" ry="2" fill="${st.lights}" />
        <ellipse cx="148" cy="53" rx="4" ry="2" fill="${st.lights}" />
      </svg>

      <div class="status-box ${st.status}">
        <span class="dir ${directionClass(action, raw)}" aria-label="${action}"></span>
      </div>

      <div class="metrics">
        <div class="metric-line"><b>Speed:</b> ${speed}</div>

        <div class="metric-line timer-line">
          <b>${tDisp.label}</b>
          <span class="timer-value ${tDisp.running ? 'timer-running' : ''} ${tDisp.done ? 'timer-done' : ''}"
                data-timer="${slotName}">
            ${tDisp.value}
          </span>
        </div>

        <div class="muted">Seen: ${seenStr}</div>
        <div class="raw">${raw}</div>
      </div>

      ${big ? `
        <div id="focus-controls">
          <button class="control-btn" onclick="sendRobotCommand('${slotName}','START');event.stopPropagation();">&#9654; On</button>
        </div>
      ` : ""}
    </div>
  `;
}

function bindCardClicks(){
  document.querySelectorAll(".robot-card, .robot-card-big").forEach(el=>{
    const k=el.getAttribute("data-key");
    el.onclick = ()=>{ focus = (focus===k)?null:k; render(); };
    el.onkeyup = (e)=>{ if(e.key==="Enter"){ focus=(focus===k)?null:k; render(); } };
  });
}

function render(){
  const dash=document.getElementById("dashboard-flex");
  if(!dash) return;

  if(focus){
    const big = allRobots.find(x=>x.slot===focus);
    const minis = allRobots.filter(x=>x.slot!==focus);

    dash.innerHTML = cardHTML(big.slot, big.data, true) + `<div id="sidebar-right"></div>`;
    const side=document.getElementById("sidebar-right");
    minis.forEach(m=> side.innerHTML += cardHTML(m.slot, m.data, false));
  }else{
    dash.innerHTML = allRobots.map(x=>cardHTML(x.slot, x.data, false)).join("");
  }

  // ✅ Always re-bind click handlers after we replace innerHTML
  bindCardClicks();
}

// ✅ Instead of re-rendering everything every 100ms,
// only update the timer text spans that already exist.
function tickTimers(){
  ROBOTS.forEach(name=>{
    const el = document.querySelector(`[data-timer="${name}"]`);
    if(!el) return;

    const t = timers[name];
    if(!t.started) {
      el.textContent = "--:--.--";
      el.classList.remove("timer-running","timer-done");
      return;
    }

    if(t.endMs !== null){
      el.textContent = formatMs(t.endMs - t.startMs);
      el.classList.remove("timer-running");
      el.classList.add("timer-done");
      return;
    }

    el.textContent = formatMs(Date.now() - t.startMs);
    el.classList.add("timer-running");
    el.classList.remove("timer-done");
  });
}

// ----- Main loop: fetch API -> update UI -> relay tick -----
async function fetchRobots(){
  try{
    const res = await fetch("/api/robots", { cache:"no-store" });
    const payload = await res.json();
    const arr = normalizePayload(payload);

    allRobots = ROBOTS.map(name => ({ slot:name, data: matchRobot(name, arr) }));

    setTop(`Live • last update ${new Date().toLocaleTimeString()}`);
    render();
    await relayTick();
  }catch(e){
    setTop("Disconnected • retrying…");
  }
}

// ----- Buttons -----
document.getElementById("relayBtn").onclick = ()=>{
  relayEnabled = !relayEnabled;
  if(relayEnabled){
    relayStep=0;
    lastRelaySentAt=0;
    setRelayText("Relay: watching Pink Panther…");
  }else{
    setRelayText("Relay: idle");
  }
  setRelayBtn();
};

// Start everything
setRelayBtn();
fetchRobots();
setInterval(fetchRobots, 800);
setInterval(tickTimers, 100);  // ✅ smooth timers without breaking clicking
</script>
</body>
</html>
